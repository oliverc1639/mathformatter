<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Math Symbol Writer — caret fix + Report Problem</title>
<style>
  :root { --bg:#0b0c10; --panel:#12131a; --ink:#e7e9ee; --muted:#9aa3b2; --accent:#6ee7ff; --edge:#1c1e29; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  .wrap{max-width:980px;margin:40px auto;padding:0 16px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  header h1{font-size:20px;margin:0}
  .pill{font-size:12px;color:var(--panel);background:var(--accent);padding:2px 8px;border-radius:999px}
  .muted{color:var(--muted);font-size:13px}
  .kbd{border:1px solid #2a2d3e;background:#11131b;border-radius:8px;padding:2px 6px;font-family:ui-monospace,Menlo,Consolas,monospace}

  .card{background:var(--panel);border-radius:16px;padding:14px;border:1px solid var(--edge);box-shadow:0 1px 0 rgba(255,255,255,.03) inset}
  #editor{min-height:300px;background:#0f1017;border:1px solid #242635;border-radius:12px;padding:12px;outline:none;white-space:pre-wrap;word-break:break-word}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  button{appearance:none;border:1px solid #2a2d3e;background:#161823;color:var(--ink);padding:8px 12px;border-radius:12px;cursor:pointer}
  button:hover{border-color:#3a3f58}

  /* Math layout */
  .frac{display:inline-flex;flex-direction:column;align-items:center;vertical-align:middle;line-height:1}
  .frac .bar{width:100%;height:1px;background:#e7e9ee;margin:2px 0}
  .sqrt{display:inline-flex;align-items:flex-end;vertical-align:middle;line-height:1}
  .sqrt .rad{font-size:1.2em;margin-right:2px}
  .sqrt .radicand{display:inline-block;border-top:1px solid #e7e9ee;padding-top:2px}
  .sum{display:inline-flex;align-items:center;gap:2px;vertical-align:middle;line-height:1}
  .sum .sig{font-size:1.2em}
  .sum .lims{display:inline-flex;flex-direction:column;align-items:center}
  .mb{display:inline-block;vertical-align:middle}
  .gap{display:inline-block}              /* contains ZWSP to click through */
  .caretAnchor{display:inline-block}      /* contains ZWSP; we also add a plain text node after this for the caret */

  /* Commands UI */
  .commands{margin-top:16px;border:1px solid var(--edge);border-radius:14px;padding:12px;color:#062a33;background:#0d141a}
  .commands h3{margin:0 0 10px 0;color:var(--accent);font-size:14px}
  .cmd-bar{display:flex;flex-wrap:wrap;gap:10px}
  .cmd{border:1px solid #1a222b;background:#0b1016;color:var(--accent);border-radius:12px;padding:10px 12px;font-size:13px;line-height:1.45;flex:0 1 auto}
  .cmd b{color:#8be9ff}
  code{background:#0f1017;border:1px solid #222434;border-radius:6px;padding:0 4px}

  /* Toggle */
  .toggle{display:flex;align-items:center;gap:8px;margin:8px 0 4px}
  .switch{position:relative;width:52px;height:28px}
  .switch input{opacity:0;width:0;height:0}
  .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#2a2d3e;border-radius:999px;transition:.2s}
  .slider:before{position:absolute;content:"";height:22px;width:22px;left:3px;top:3px;background:#fff;border-radius:50%;transition:.2s}
  input:checked + .slider{background:#26c6da}
  input:checked + .slider:before{transform:translateX(24px)}
  .warn{color:#ffd479;font-size:12px;margin-left:8px}

  /* Report Problem */
  .reportWrap{margin-top:14px}
  .reportBtn{font-weight:700}
  .reportPanel{margin-top:8px;display:none}
  .reportPanel textarea{width:100%;min-height:110px;background:#0f1017;color:var(--ink);border:1px solid #242635;border-radius:10px;padding:10px;resize:vertical}
  .success{color:#98ffa6;font-size:13px;margin-top:8px}
  .error{color:#ff9b9b;font-size:13px;margin-top:8px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Math Symbol Writer</h1>
      <span class="pill">Enter-to-Confirm (default)</span>
      <span class="muted">Enter converts the last command (or inserts a newline if nothing to convert).</span>
    </header>

    <section class="card">
      <div class="toggle">
        <label class="switch">
          <input id="enterModeSwitch" type="checkbox" checked>
          <span class="slider"></span>
        </label>
        <div>
          <div><b>Enter-to-Confirm</b> <span class="muted">(recommended)</span></div>
          <div id="modeNote" class="muted">Convert only the most recent command; existing math stays intact.</div>
        </div>
      </div>
      <div id="liveWarning" class="warn" style="display:none;">Live Replace is ON — converts as you type; Enter makes a newline.</div>

      <div id="editor" contenteditable="true" spellcheck="false" aria-label="Math input area"></div>

      <div class="row">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
        <button id="copyText">Copy (plain text)</button>
        <button id="copyHTML">Copy (rich HTML)</button>
        <button id="clear">Clear</button>
        <span id="copied" class="muted"></span>
      </div>

      <div class="commands">
        <h3>Commands</h3>
        <div class="cmd-bar">
          <div class="cmd"><b>Greek</b><br>
            lower → α β γ δ ε ζ η θ ι κ λ μ ν ξ π ρ σ τ υ φ χ ψ ω<br>
            ALL-CAPS → Α Β Γ Δ Ε Ζ Η Ι Κ Λ Μ Ν Ξ Π Ρ Σ Τ Υ Φ Χ Ψ Ω
          </div>
          <div class="cmd"><b>Ops & constants</b><br>
            sum ∑ · product/prod ∏ · integral/int ∫ · grad ∇ · partial ∂ · sqrt √ · inf ∞ · ohm Ω · pi π · times × · cdot · · deg ° · perp ⟂ · angle ∠ · nought → ₀
          </div>
          <div class="cmd"><b>Relations & arrows</b><br>
            <= ≤ · >= ≥ · != ≠ · == ≡ · ~= ≈ · -> → · <- ← · <-> ↔ · to →
          </div>
          <div class="cmd"><b>Sup/Sub</b><br>
            x^10 → x¹⁰ · x^(n+1) → xⁿ⁺¹ · y_(i) → y<sub>i</sub> · vnought → v₀
          </div>
          <div class="cmd"><b>Fractions</b><br>
            a//b · (a)/(b) — sides can be expressions: <code>3//x+1</code>, <code>A^2//(b-1)</code>, <code>sqrtx+5//y^(n+1)</code>.
          </div>
          <div class="cmd"><b>Summation limits</b><br>
            <code>sum x=1..n</code> or <code>sumx=1..n</code> → Σ
          </div>
          <div class="cmd"><b>Functions auto-parens</b><br>
            <code>sin)</code> → <code>sin()</code> (sin cos tan cot sec csc log ln exp max min sqrt)
          </div>
        </div>

        <!-- Report Problem UI -->
        <div class="reportWrap">
          <button id="reportBtn" class="reportBtn">Report Problem</button>
          <div id="reportPanel" class="reportPanel">
            <textarea id="reportMsg" placeholder="Describe what you typed and what broke. Example: 'Typed alpha then Enter twice; symbol moved to next line.'"></textarea>
            <div class="row" style="margin-top:8px;">
              <button id="reportSubmit">Submit</button>
              <button id="reportCancel">Cancel</button>
            </div>
            <div id="reportStatus" class="muted"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
/* ===== DOM helpers ===== */
const ed = document.getElementById('editor');

function getCaretOffset(root){
  const sel = window.getSelection();
  if (!sel.rangeCount) return 0;
  const r = sel.getRangeAt(0);
  const pre = r.cloneRange();
  pre.selectNodeContents(root);
  pre.setEnd(r.endContainer, r.endOffset);
  return pre.toString().length;
}
function rangeFromOffsets(root, start, end){
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  let node, idx = 0, startNode=null, startOff=0, endNode=null, endOff=0;
  while ((node = walker.nextNode())){
    const len = node.nodeValue.length;
    if (!startNode && idx + len >= start){ startNode = node; startOff = start - idx; }
    if (idx + len >= end){ endNode = node; endOff = end - idx; break; }
    idx += len;
  }
  if (!startNode) { startNode = ed; startOff = 0; }
  if (!endNode)   { endNode = startNode; endOff = startOff; }
  const r = document.createRange();
  try { r.setStart(startNode, startOff); r.setEnd(endNode, endOff); }
  catch { r.selectNodeContents(root); r.collapse(false); }
  return r;
}
function textSlice(root, start, end){ return rangeFromOffsets(root, start, end).toString(); }

function insertAfter(refNode, newNode){
  if (!refNode || !refNode.parentNode) return;
  if (refNode.nextSibling) refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  else refNode.parentNode.appendChild(newNode);
}
function placeCaretInTextNode(textNode, offset){
  const sel = window.getSelection();
  const r = document.createRange();
  r.setStart(textNode, Math.min(offset, textNode.length));
  r.collapse(true);
  sel.removeAllRanges(); sel.addRange(r);
}

/* Replace [start,end) with HTML, add anchor + a plain text caret node AFTER it; place caret in that text node */
function replaceRangeWithHTML(start, end, html){
  const r = rangeFromOffsets(ed, start, end);
  r.deleteContents();

  const temp = document.createElement('div');
  temp.innerHTML = html;
  const frag = document.createDocumentFragment();
  const nodes = Array.from(temp.childNodes);
  nodes.forEach(n => frag.appendChild(n));
  r.insertNode(frag);

  // find trailing .gap (we inserted one in wrapMB)
  let gap = null;
  let last = nodes[nodes.length - 1] || null;
  if (last && last.nodeType === 1 && last.classList.contains('gap')) gap = last;
  if (!gap && last && last.previousSibling && last.previousSibling.classList && last.previousSibling.classList.contains('gap')) gap = last.previousSibling;

  // ensure a caretAnchor after gap
  let anchor = (gap && gap.nextSibling && gap.nextSibling.classList && gap.nextSibling.classList.contains('caretAnchor')) ? gap.nextSibling : null;
  if (!anchor){
    anchor = document.createElement('span');
    anchor.className = 'caretAnchor';
    anchor.textContent = '\u200B';
    if (gap) insertAfter(gap, anchor);
    else if (last) insertAfter(last, anchor);
  } else {
    anchor.textContent = '\u200B';
  }
  // CRITICAL: put caret in a *plain text node* after the anchor, not inside any span
  let caretText = (anchor.nextSibling && anchor.nextSibling.nodeType === Node.TEXT_NODE) ? anchor.nextSibling : null;
  if (!caretText){
    caretText = document.createTextNode('\u200B');
    insertAfter(anchor, caretText);
  } else {
    caretText.nodeValue = '\u200B';
  }
  placeCaretInTextNode(caretText, caretText.length);
}

/* ===== symbols & builders ===== */
const supMap = {'0':'⁰','1':'¹','2':'²','3':'³','4':'⁴','5':'⁵','6':'⁶','7':'⁷','8':'⁸','9':'⁹','+':'⁺','-':'⁻','=':'⁼','(':'⁽',')':'⁾','n':'ⁿ','i':'ⁱ','a':'ᵃ','b':'ᵇ','c':'ᶜ','d':'ᵈ','e':'ᵉ','f':'ᶠ','g':'ᵍ','h':'ʰ','j':'ʲ','k':'ᵏ','l':'ˡ','m':'ᵐ','o':'ᵒ','p':'ᵖ','r':'ʳ','s':'ˢ','t':'ᵗ','u':'ᵘ','v':'ᵛ','w':'ʷ','x':'ˣ','y':'ʸ','z':'ᶻ','q':'q'};
function esc(s){ return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function toSuper(s){ return s.split('').map(c => supMap[c] ?? c).join(''); }
function toSuperSmart(s){ const ok=[...s].every(c=>supMap[c]!==undefined); return ok?toSuper(s):`<sup>${esc(s)}</sup>`; }

const greekLower = {alpha:'α',beta:'β',gamma:'γ',delta:'δ',epsilon:'ε',zeta:'ζ',eta:'η',theta:'θ',iota:'ι',kappa:'κ',lambda:'λ',mu:'μ',nu:'ν',xi:'ξ',pi:'π',rho:'ρ',sigma:'σ',tau:'τ',upsilon:'υ',phi:'φ',chi:'χ',psi:'ψ',omega:'ω'};
const greekUpper = {ALPHA:'Α',BETA:'Β',GAMMA:'Γ',DELTA:'Δ',EPSILON:'Ε',ZETA:'Ζ',ETA:'Η',THETA:'Θ',IOTA:'Ι',KAPPA:'Κ',LAMBDA:'Λ',MU:'Μ',NU:'Ν',XI:'Ξ',PI:'Π',RHO:'Ρ',SIGMA:'Σ',TAU:'Τ',UPSILON:'Υ',PHI:'Φ',CHI:'Χ',PSI:'Ψ',OMEGA:'Ω'};
const WORDS = {sum:'∑',prod:'∏',int:'∫',integ:'∫',grad:'∇',partial:'∂',sqrt:'√',inf:'∞',times:'×',cdot:'·',deg:'°',perp:'⟂',angle:'∠',pi:'π',ohm:'Ω',nought:'₀'};

function normalizeTokenOnce(tok){
  let s = tok;
  s = s.replace(/^partial\s+derivative$/i, 'partial');
  s = s.replace(/^square\s+root$/i, 'sqrt');
  s = s.replace(/^degrees?$/i, 'deg');
  const map = {integral:'int', product:'prod', gradient:'grad', nabla:'grad', infinity:'inf', perpendicular:'perp'};
  for (const k of Object.keys(map)){ if (new RegExp(`^${k}$`,'i').test(s)) { s = map[k]; break; } }
  return s;
}

/* wrappers (gap includes ZWSP; we add an anchor + plain text caret node after insert) */
function wrapMB(inner){
  return `<span class="mb" contenteditable="false">${inner}</span><span class="gap">\u200B</span>`;
}
function makeFrac(a,b){ return wrapMB(`<span class="frac"><span class="num">${a}</span><span class="bar"></span><span class="den">${b}</span></span>`); }
function makeSqrt(inner){ return wrapMB(`<span class="sqrt"><span class="rad">√</span><span class="radicand">${inner}</span></span>`); }
function makeSum(bottom, top){ return wrapMB(`<span class="sum"><span class="sig">∑</span><span class="lims"><sub>${bottom}</sub><sup>${top}</sup></span></span>`); }

/* ===== modes & flags ===== */
let enterMode = true;
const enterSwitch = document.getElementById('enterModeSwitch');
const liveWarn   = document.getElementById('liveWarning');
const modeNote   = document.getElementById('modeNote');
function updateModeUI(){
  if (enterMode){ liveWarn.style.display='none'; modeNote.textContent='Convert only the most recent command; existing math stays intact.'; }
  else          { liveWarn.style.display='block'; modeNote.textContent='Live Replace is active; Enter always makes a newline.'; }
}
enterSwitch.addEventListener('change', ()=>{ enterMode = enterSwitch.checked; updateModeUI(); });

let isConverting = false;

/* trim trailing spaces/ZWSP */
function rtrimSpacesZWSP(s){
  const before = s.length;
  const out = s.replace(/[\u200B\s]+$/u, '');
  return { text: out, trim: before - out.length };
}

/* Convert last token near caret; returns true if converted */
function convertLastAtCaret(){
  if (isConverting) return false;
  isConverting = true;
  try{
    const caret = getCaretOffset(ed);
    const WIN = 320;
    const start = Math.max(0, caret - WIN);
    let win = textSlice(ed, start, caret);

    const { text: winTrim } = rtrimSpacesZWSP(win);

    const FRACTOKEN = '([A-Za-z0-9()+\\-*/^\\.]+)';
    const patterns = [
      { re: /([A-Za-z0-9])\^\(([^)]*)\)$/, make: m => esc(m[1]) + toSuperSmart(m[2]) },
      { re: /([A-Za-z0-9])\^([A-Za-z0-9+\-=]+)$/, make: m => esc(m[1]) + toSuperSmart(m[2]) },

      { re: new RegExp(`${FRACTOKEN}\\s*\\/\\/\\s*${FRACTOKEN}$`), make: m => makeFrac(esc(m[1]), esc(m[2])) },
      { re: /\(([^)]+)\)\s*\/\s*\(([^)]+)\)$/, make: m => makeFrac(esc(m[1]), esc(m[2])) },

      { re: /(?:sqrt|√)([^\s]+)$/, make: m => makeSqrt(esc(m[1])) },

      { re: /\bsum\s*([A-Za-z]+)\s*=\s*([^\s.]+)\s*\.\.\s*([^\s]+)$/, make: m => makeSum(`${esc(m[1])}=${esc(m[2])}`, esc(m[3])) },
      { re: /\bsum([A-Za-z]+)\s*=\s*([^\s.]+)\s*\.\.\s*([^\s]+)$/,   make: m => makeSum(`${esc(m[1])}=${esc(m[2])}`, esc(m[3])) },

      { re: /(?:<=|>=|!=|<->|->|<-|to)$/, make: m => ({'<=':'≤','>=':'≥','!=':'≠','<->':'↔','->':'→','<-':'←','to':'→'})[m[0]] },

      { re: /([A-Za-z]+)$/, make: m => {
          const tailRaw = m[1];
          if (greekUpper[tailRaw]) return wrapMB(greekUpper[tailRaw]);
          const low = tailRaw.toLowerCase();
          if (greekLower[low])   return wrapMB(greekLower[low]);
          const canon = normalizeTokenOnce(tailRaw).toLowerCase();
          if (WORDS[canon])      return wrapMB(WORDS[canon]);
          return null;
        }
      },
    ];

    for (const p of patterns){
      const m = winTrim.match(p.re);
      if (m){
        const matchStartInWin = winTrim.lastIndexOf(m[0]);
        const absStart = start + matchStartInWin;
        const absEnd   = start + matchStartInWin + m[0].length;
        const rep = p.make(m);
        if (!rep) break;
        replaceRangeWithHTML(absStart, absEnd, rep); // caret placed in plain text node after symbol
        return true;
      }
    }
    return false;
  } finally {
    setTimeout(()=>{ isConverting = false; }, 0);
  }
}

/* Clicking / Arrow-right: hop past math blocks to the caret text node */
function moveCaretAfterMB(node){
  let mb = node;
  while (mb && !(mb.classList && mb.classList.contains('mb'))) mb = mb.parentNode;
  if (!mb) return false;
  let anchor = (mb.nextSibling && mb.nextSibling.classList && mb.nextSibling.classList.contains('gap')) ? mb.nextSibling.nextSibling : null;
  if (!(anchor && anchor.classList && anchor.classList.contains('caretAnchor'))) anchor = null;
  let caretText = (anchor && anchor.nextSibling && anchor.nextSibling.nodeType === Node.TEXT_NODE) ? anchor.nextSibling : null;
  if (caretText){ placeCaretInTextNode(caretText, caretText.length); return true; }
  // If caretText missing (e.g., pasted content), create it
  const a = anchor || mb.nextSibling;
  const txt = document.createTextNode('\u200B');
  insertAfter(a, txt);
  placeCaretInTextNode(txt, 1);
  return true;
}
ed.addEventListener('mousedown', (e)=>{
  const t = e.target;
  if (t.closest('.mb')){ e.preventDefault(); moveCaretAfterMB(t); }
});
ed.addEventListener('keydown', (e)=>{
  if (e.key === 'ArrowRight'){
    const sel = window.getSelection();
    if (sel.rangeCount){
      const node = sel.getRangeAt(0).endContainer;
      const insideMB = node.nodeType !== 1 ? (node.parentNode && node.parentNode.closest('.mb')) : node.closest('.mb');
      if (insideMB){ e.preventDefault(); moveCaretAfterMB(insideMB); return; }
    }
  }
});

/* ENTER key behavior */
const FUNC_WORDS = ['sin','cos','tan','cot','sec','csc','log','ln','exp','max','min','sqrt'];
ed.addEventListener('keydown', (e)=>{
  // Auto () on ")"
  if (e.key === ')'){
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const r = sel.getRangeAt(0), pre = r.cloneRange(); pre.setStart(ed, 0);
    const before = pre.toString();
    const m = before.match(/(?:^|[\s(])([A-Za-z]{2,})$/);
    if (m && FUNC_WORDS.includes(m[1].toLowerCase())){
      e.preventDefault();
      document.execCommand('insertText', false, '()');
      const rr = rangeFromOffsets(ed, getCaretOffset(ed)-1, getCaretOffset(ed)-1);
      const sel2 = window.getSelection(); sel2.removeAllRanges(); sel2.addRange(rr);
      return;
    }
  }

  if (e.key === 'Enter'){
    if (enterMode){
      e.preventDefault();
      const did = convertLastAtCaret();
      if (!did){
        // robust newline: insert exactly where caret is (which is in a plain text node)
        document.execCommand('insertLineBreak');
      }
    } else {
      // live mode: newline; conversions happen on input
    }
    return;
  }
});

/* Live conversions */
ed.addEventListener('input', ()=>{
  if (!enterMode && !isConverting) convertLastAtCaret();
  snapshot();
});

/* History / copy / init */
const hist = { stack: [], index: -1, freeze: false };
function snapshot(){
  if (hist.freeze) return;
  const state = { html: ed.innerHTML, caret: getCaretOffset(ed) };
  if (hist.index >= 0 && hist.stack[hist.index].html === state.html) return;
  hist.stack = hist.stack.slice(0, hist.index + 1);
  hist.stack.push(state); if (hist.stack.length > 200) hist.stack.shift();
  hist.index = hist.stack.length - 1;
}
function restore(idx){
  if (idx < 0 || idx >= hist.stack.length) return;
  hist.freeze = true;
  ed.innerHTML = hist.stack[idx].html;
  const caret = Math.min(hist.stack[idx].caret, ed.innerText.length);
  const r = rangeFromOffsets(ed, caret, caret);
  const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(r);
  hist.index = idx; hist.freeze = false;
}
document.getElementById('undoBtn').onclick = ()=>restore(hist.index-1);
document.getElementById('redoBtn').onclick = ()=>restore(hist.index+1);
document.addEventListener('keydown', (e)=>{
  const meta = e.ctrlKey || e.metaKey;
  if (meta && e.key.toLowerCase()==='z'){ e.preventDefault(); if (e.shiftKey) restore(hist.index+1); else restore(hist.index-1); }
});
function copyFallback(text){ const ta=document.createElement('textarea'); ta.value=text||''; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); }
async function copyRich(){
  const html = ed.innerHTML;
  if (window.ClipboardItem) {
    const item = new ClipboardItem({'text/html': new Blob([html], {type:'text/html'}), 'text/plain': new Blob([ed.innerText], {type:'text/plain'})});
    await navigator.clipboard.write([item]).catch(()=>copyFallback(ed.innerText));
  } else copyFallback(ed.innerText);
}
async function copyPlain(){ await navigator.clipboard.writeText(ed.innerText).catch(()=>copyFallback(ed.innerText)); }
document.getElementById('copyHTML').onclick = async ()=>{ await copyRich(); flash('Copied (rich HTML)!'); };
document.getElementById('copyText').onclick = async ()=>{ await copyPlain(); flash('Copied (plain text)!'); };
document.getElementById('clear').onclick = ()=>{ ed.innerHTML=''; snapshot(); ed.focus(); };
function flash(msg){ const el=document.getElementById('copied'); el.textContent=msg; setTimeout(()=>el.textContent='',1400); }

/* ===== Report Problem UI ===== */
const reportBtn = document.getElementById('reportBtn');
const reportPanel = document.getElementById('reportPanel');
const reportMsg = document.getElementById('reportMsg');
const reportSubmit = document.getElementById('reportSubmit');
const reportCancel = document.getElementById('reportCancel');
const reportStatus = document.getElementById('reportStatus');

reportBtn.addEventListener('click', ()=>{
  reportPanel.style.display = reportPanel.style.display === 'none' || reportPanel.style.display === '' ? 'block' : 'none';
  if (reportPanel.style.display==='block') reportMsg.focus();
});
reportCancel.addEventListener('click', ()=>{
  reportPanel.style.display = 'none';
  reportStatus.textContent = '';
});

reportSubmit.addEventListener('click', ()=>{
  const msg = (reportMsg.value || '').trim();
  if (!msg){ reportStatus.textContent = 'Please write a short description.'; return; }

  // Build a mailto with some context
  const subject = encodeURIComponent('Math Symbol Writer — Problem Report');
  const context = `\n\n---\nEditor HTML (truncated):\n` + (ed.innerHTML || '').slice(0, 4000);
  const body = encodeURIComponent(msg + context);
  const mailto = `mailto:oliver.c1639@gmail.com?subject=${subject}&body=${body}`;

  // Hide UI and show success
  reportPanel.style.display = 'none';
  reportStatus.className = 'success';
  reportStatus.textContent = 'Thanks! Your mail app should open — just hit send.';

  // Trigger mail client
  window.location.href = mailto;

  // OPTIONAL: If you later want direct send without a mail app, uncomment and configure EmailJS or your API here:
  /*
  emailjs.init('YOUR_PUBLIC_KEY');
  emailjs.send('YOUR_SERVICE_ID','YOUR_TEMPLATE_ID',{ message: msg, snapshot: ed.innerHTML })
    .then(()=>{ reportStatus.className='success'; reportStatus.textContent='Sent!'; })
    .catch(()=>{ reportStatus.className='error'; reportStatus.textContent='Failed to send. Please try again or use your mail app.'; });
  */
});

/* ===== Init ===== */
window.addEventListener('load', ()=>{
  ed.innerHTML =
`Fix: symbols no longer follow you when pressing Enter again.
Try:
  alpha (Enter) → α, then (Enter) → newline below, α stays put.

Also added bold “Report Problem” under Commands.`;
  updateModeUI();
  snapshot();
});
</script>
</body>
</html>
